# -*- coding: utf-8 -*-
"""
/***************************************************************************
 sidewalkreator
                                 A QGIS plugin
 Plugin designated to create the Geometries of Sidewalks (separated from streets) based on OpenStreetMap Streets, given a bounding polygon, outputting to JOSM format. It is mostly intended for acessibility Mapping.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-29
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Kaue de Moraes Vestena
        email                : kauemv2@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# import os.path
import os, requests, codecs, time
# from os import environ

# standard libraries
# import codecs # for osm2geojson

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.gui import QgsMapLayerComboBox, QgsMapCanvas
from qgis.PyQt.QtWidgets import QAction
# additional qgis/qt imports:
from qgis import processing
from qgis.core import QgsMapLayerProxyModel, QgsFeature, QgsCoordinateReferenceSystem, QgsVectorLayer, QgsProject, QgsApplication, edit, QgsGeometryUtils


# pure Qt imports, keep at minimun =P
from PyQt5.QtWidgets import QTableWidgetItem
from PyQt5.QtWidgets import QDialogButtonBox
from PyQt5.QtCore import QVariant



# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .osm_sidewalkreator_dialog import sidewalkreatorDialog


# for third-party libraries installation
import subprocess
import sys


def install_pypi(packagename):
    subprocess.check_call([sys.executable, "-m", "pip", "install", packagename])


# importing or installing third-party libraries
try:
    # import geopandas as gpd
    import osm2geojson
except:
    pkg_to_be_installed = ['osm2geojson'] #'geopandas'

    for packagename in pkg_to_be_installed:
        install_pypi(packagename)


# # then again, because its best to raise an error
# import geopandas as gpd
import osm2geojson

# # internal dependencies:
from .osm_fetch import *
from .generic_functions import *
from .parameters import *



############################
##### GLOBAL-SCOPE
###########################

# to path stuff don't get messy:

# homepath = os.environ['HOME']
# homepath = os.path.expanduser('~')

# user_profile = 'default' #TODO: read from session

# TODO: adapt for windows aswell (actually we may only need to test the current solution)

# basepathp1 = '.local/share/QGIS/QGIS3/profiles'
# basepath = os.path.join(homepath,basepathp1,user_profile,basepathp2)

profilepath = QgsApplication.qgisSettingsDirPath()
base_pluginpath_p2 = 'python/plugins/osm_sidewalkreator'
basepath = os.path.join(profilepath,base_pluginpath_p2)
temps_path = os.path.join(basepath,'temporary')

print(basepath)
reports_path = os.path.join(basepath,'reports')

assets_path = os.path.join(basepath,'assets')


basic_folderpathlist = [temps_path,reports_path,assets_path]
for folderpath in basic_folderpathlist:
    create_dir_ifnotexists(folderpath)

class sidewalkreator:
    """QGIS Plugin Implementation."""

    # to control current language:
    current_lang = 'en'

    # variables to control wheter change in language should change labels
    change_input_labels = True

    # to control wheter one shall ignore a "sidewalks already drawn" warning:
    ignore_sidewalks_already_drawn = False

    # no buildings is the most general situation
    no_buildings = True

    # if method to split sidewalks using addrs and/or building centroids (HERE NAMED POIS) are avaliable (unavaliable is the most general situation, there's lots of areas without a single one)
    POI_split_avaliable = False

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'sidewalkreator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OSM SidewalKreator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None



        ###############################################
        ####    My code on __init__
        #########################################
        # language_selector
        # self.dlg.opt_ptbr.checked.connect(self.change_language)


        self.session_debugpath = os.path.join(reports_path,'session_debug.txt')

        with open(self.session_debugpath,'w+') as session_report:
            session_report.write('session_report:\n')
            # session_report.write(session_debugpath+'\n')
            # session_report.write(homepath)



    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('sidewalkreator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):


        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/osm_sidewalkreator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Create Sidewalks for OSM'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OSM SidewalKreator'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = sidewalkreatorDialog()


            

            # setting items that should not be visible at beginning:
            self.dlg.sidewalks_warning.setHidden(True)
            self.dlg.widths_hint.setHidden(True)
            self.dlg.ignore_already_drawn_btn.setHidden(True)


            # # # THE FUNCTION CONNECTIONS
            self.dlg.datafetch.clicked.connect(self.call_get_osm_data)
            self.dlg.clean_data.clicked.connect(self.data_clean)
            self.dlg.generate_sidewalks.clicked.connect(self.draw_sidewalks)
            self.dlg.ignore_already_drawn_btn.clicked.connect(self.ignore_already_drawn_fcn)
            self.dlg.add_osm_basemap.clicked.connect(self.add_osm_basemap_func)
            self.dlg.add_bing_base.clicked.connect(self.add_bing_baseimg_func)
            self.dlg.generate_crossings.clicked.connect(self.draw_crossings)
            self.dlg.split_sidewalks.clicked.connect(self.sidewalks_splitting)
            




            # cancel means reset AND close
            self.dlg.button_box.button(QDialogButtonBox.Reset).clicked.connect(self.reset_fields)
            self.dlg.button_box.button(QDialogButtonBox.Cancel).clicked.connect(self.reset_fields)


            # language stuff
            self.dlg.opt_ptbr.clicked.connect(self.change_language_ptbr)
            self.dlg.opt_en.clicked.connect(self.go_back_to_english)
            self.dlg.input_layer_selector.layerChanged.connect(self.get_input_layer)



            # # # handles and modifications/ors:
            self.dlg.input_layer_selector.setFilters(QgsMapLayerProxyModel.PolygonLayer)
            self.dlg.input_layer_selector.setAllowEmptyLayer(True)
            self.dlg.input_layer_selector.setLayer(None)
            # thx: https://github.com/qgis/QGIS/issues/38472

        # check in runtime if those folders actually exists
        for folderpath in basic_folderpathlist:
            create_dir_ifnotexists(folderpath)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    ##################################
    ##### THE CLASS SCOPE
    ##################################

    def add_layer_canvas(self,layer):
        # canvas = QgsMapCanvas()
        QgsProject.instance().addMapLayer(layer)
        QgsMapCanvas().setExtent(layer.extent())
        # canvas.setLayerSet([QgsMapCanvasLayer(layer)])

    def change_language_ptbr(self):
        self.current_lang = 'ptbr'

        # # frozing selection if you opt for ptbr:
        # self.dlg.opt_ptbr.setEnabled(False)
        # self.dlg.opt_en.setEnabled(False)

        self.change_all_labels_bylang()

    def go_back_to_english(self):
        self.current_lang = 'en'

        self.change_all_labels_bylang()

    def change_all_labels_bylang(self):
        info_tuples = [
            # tuples: (qt-dlg_element,english_text,ptbr_text)
            (self.dlg.lang_label,"Language: ","Idioma: "),
            (self.dlg.input_pol_label,"Input Polygon: ","Polígono de Entrada" ),
            (self.dlg.table_txt1,'default widths for tag values','larguras-padrão para valores'),
            (self.dlg.table_txt2,'"0" means ignore features','"0": ignorar feições'),
            (self.dlg.output_file_label,'Output File:','Arquivo de Saída:'),
            (self.dlg.datafetch,'Fetch Data','Obter Dados'),
            (self.dlg.input_status,'waiting a valid input...','aguardando uma entrada válida...',self.change_input_labels),
            (self.dlg.input_status_of_data,'waiting for data...','aguardando dados...',self.change_input_labels),
            (self.dlg.button_box.button(QDialogButtonBox.Cancel),"Cancel","Cancelar"),
            (self.dlg.button_box.button(QDialogButtonBox.Reset),"Reset","Reiniciar"),
            (self.dlg.clean_data,'Clean OSM Data and\nCompute Intersections','Limp. dados OSM e\nGerar Interseções'),
            (self.dlg.sidewalks_warning,"Some Sidewalks are already drawn!!! You must reshape your input polygon!!!\n(in a future release,that stuff shall be handled properly...)","Já há algumas calçadas mapeadas!! Você deverá Redesenhar seu polígono de entrada!!\n(em uma versão futura será lidado adequadamente)"),
            (self.dlg.check_if_overlaps_buildings,'Check if Overlaps Buildings','Testar se Sobrepõe Edificações'),
            (self.dlg.widths_hint,'Hint: You Can Set Widths\nfor Each Segment...','Dica: Você pode Inserir uma Largura\nPara Cada Segmento'),
            (self.dlg.generate_sidewalks,'Generate Sidewalks','Gerar Calçadas'),
            (self.dlg.ignore_already_drawn_btn,"I Have Reviewed the Data\nAnd It's OK!!\n(or want to draw anyway)",'Eu Revisei os Dados\nE está tudo certo!!\n(ou gerar de qualquer jeito)'),
            (self.dlg.ch_ignore_buildings,'ignore buildings\n(much faster)','ignorar edificações\n(mais rápido)'),
            (self.dlg.min_d_label,'Min Distance\nto Buildings','Distância Mínima\np. Edificaçoes'),
            (self.dlg.min_d_label,'Min Distance\nto Buildings','Dist. Min.\np. Edificaçoes'),
            (self.dlg.curveradius_label,'Curve\nRadius','Raio de\nCurvatura'),
            (self.dlg.d_to_add_label,'Distance to\nadd to Width','D. Adic.\nàs Larguras'),
            (self.dlg.min_width_label,'Min Width','Largura Mínima'),
            (self.dlg.add_osm_basemap,'+ OSM\nBase Map','+Mapa-Base\nOSM'),
            (self.dlg.add_bing_base,'+ BING\nBase Img.','+Imagens\nBING'),
            (self.dlg.generate_crossings,'Generate Crossings','Gerar Cruzamentos'),
            (self.dlg.dead_end_iters_label,'Iters. to remove\ndead-end-streets\n(0 to keep all of them)','Iter. p/ remover\nruas-sem-fim\n(0 para manter todas)'),
            (self.dlg.split_sidewalks,'Split Sidewalk Geometries','Subdividir Calçadas (Geometrias)'),
            (self.dlg.perc_draw_kerbs_label,'Kerbs\nat','Kerb*\nem.'),
            (self.dlg.opt_parallel_crossings,'in parallel to\ntransversal seg.','paralelo ao\nseg. transversal'),
            (self.dlg.opt_perp_crossings,'perpen-\ndicularly','perpendi-\ncularmente'),
            (self.dlg.label_inward_d,'distance\ninward','distância\nadentro'),






            # (self.dlg.,'',''),
            # (self.dlg.,'',''),
            # (self.dlg.,'',''),
            # (self.dlg.,'',''),

        ]



        for info_set in info_tuples:
            # What an elegant solution!!! 
            self.set_text_based_on_language(*info_set)

    def data_clean(self):

        # getting table values, before table deactivation
        higway_valuestable_dict = {}

        for i,val in enumerate(self.unique_highway_values):
            # self.dlg.higway_values_table
            higway_valuestable_dict[val] = float(self.dlg.higway_values_table.item(i,1).text())


        # disabling what should not be used afterwards
        self.dlg.clean_data.setEnabled(False)
        self.dlg.dead_end_iters_label.setEnabled(False)
        self.dlg.dead_end_iters_box.setEnabled(False)
        self.dlg.higway_values_table.setEnabled(False)

        # removing undesired tag values:
        for i,value in enumerate(self.unique_highway_values):
            # if a too small value is set, then also remove it
            if float(self.dlg.higway_values_table.item(i,1).text()) < 0.5:
                remove_features_byattr(self.clipped_reproj_datalayer,highway_tag,value)#self.unique_highway_values[i])

                # creating the 'protoblocks' layer, is a poligonization of the streets layers

        # protoblocks has been moved to here

        self.protoblocks = poligonize_lines(self.clipped_reproj_datalayer)
        self.protoblocks.setCrs(self.custom_localTM_crs) # better safe than sorry kkkk



        # dissolving so will become just one geometry:
        self.dissolved_protoblocks_0 = dissolve_tosinglepart(self.protoblocks)
        self.dissolved_protoblocks_0.setCrs(self.custom_localTM_crs) # better safe than sorry kkkk


        #adding little buffer, so features touching boundaries will be fully within
        self.dissolved_protoblocks_buff = generate_buffer(self.
        dissolved_protoblocks_0,protoblocks_buffer)
        self.dissolved_protoblocks_buff.setCrs(self.custom_localTM_crs) # better safe than sorry kkkk


        # splitting into segments:
        self.splitted_lines_name = self.string_according_language('Splitted_OSM_Lines','OSM_subdividido')

        self.splitted_lines = split_lines(self.clipped_reproj_datalayer,self.clipped_reproj_datalayer,'memory:'+self.splitted_lines_name)

        self.splitted_lines.setCrs(self.custom_localTM_crs)

        # removing lines that does not serve to form a block ('quarteirão')
        if self.dlg.dead_end_iters_box.value() == 0:
            remove_lines_from_no_block(self.splitted_lines,self.dissolved_protoblocks_buff)
        else:
            for i in range(self.dlg.dead_end_iters_box.value()):
                # without second input, the function will work just as before
                remove_lines_from_no_block(self.splitted_lines)


        ##### creating points of intersection:
        intersection_points = get_intersections(self.splitted_lines,self.splitted_lines,'TEMPORARY_OUTPUT')

        intersection_points.setCrs(self.custom_localTM_crs)


        self.filtered_intersection_name = self.string_according_language('Road_Intersections','Intersecoes_Ruas')

        self.filtered_intersection_points = remove_duplicate_geometries(intersection_points,'memory:'+self.filtered_intersection_name)

        self.filtered_intersection_points.setCrs(self.custom_localTM_crs)


        #### checking if there's a "width" column, adding if not:
        if not widths_fieldname in get_column_names(self.splitted_lines):
            create_new_layerfield(self.splitted_lines,widths_fieldname)

        # filling empty widths with values in the table:
        widths_index = self.splitted_lines.fields().indexOf(widths_fieldname)
        higway_index = self.splitted_lines.fields().indexOf(highway_tag)


        with edit(self.splitted_lines):
            for feature in self.splitted_lines.getFeatures():
                feature_attrs_list = feature.attributes()

                # only fill if no value is present
                if not feature_attrs_list[widths_index]:
                    highway_tag_val = feature_attrs_list[higway_index]
                    self.splitted_lines.changeAttributeValue(feature.id(),widths_index,higway_valuestable_dict[highway_tag_val])
                    """
                        THX: https://gis.stackexchange.com/a/133669/49900

                        NEVER USE index from enumeration (ordinal) as feature key (ID), as sometimes it's not the actual feature key (ID)

                        index (idx) =/= id
                
                    """


        # filling a column with original id within layer to recover after a operation like 
        create_fill_id_field(self.splitted_lines)

        # adding layers to canvas:
        self.add_layer_canvas(self.filtered_intersection_points)
        self.add_layer_canvas(self.splitted_lines)


        # always cleaning stuff user does not need anymore
        remove_layerlist([osm_higway_layer_finalname])

        # enabling next button and stuff:
        self.dlg.generate_sidewalks.setEnabled(True)
        self.dlg.curve_radius_box.setEnabled(True)
        self.dlg.d_to_add_box.setEnabled(True)
        self.dlg.curveradius_label.setEnabled(True)
        self.dlg.d_to_add_label.setEnabled(True)

        self.dlg.widths_hint.setHidden(False)

        # to say to the user: it's not the global progress, 
        # its just to that part
        self.dlg.datafetch_progressbar.setEnabled(False)

        

        if not self.no_buildings:
            self.dlg.check_if_overlaps_buildings.setEnabled(True)
            self.dlg.min_d_label.setEnabled(True)
            self.dlg.min_d_buildings_box.setEnabled(True)
            self.dlg.min_width_box.setEnabled(True)
            self.dlg.min_width_label.setEnabled(True)


        

        # self.replace_vectorlayer(osm_higway_layer_finalname,outputpath_splitted)

    def add_osm_basemap_func(self):
        layername = self.string_according_language('OSM Default','OSM Padrão')

        add_tms_layer(osm_basemap_str,layername)

        self.dlg.add_osm_basemap.setEnabled(False)

    def add_bing_baseimg_func(self):
        layername = self.string_according_language('BING Aerial','Imagens BING')

        add_tms_layer(bing_baseimg_str,layername)

        self.dlg.add_bing_base.setEnabled(False)


    def sidewalks_splitting(self):
        # disabling what wouldnt be needed adterwars:
        self.dlg.split_sidewalks.setEnabled(False)

        for feature in self.protoblocks.getFeatures():
            polygon_vertex_list = feature.geometry().simplify().asPolygon()[0]






    def draw_crossings(self):

        # stuff to be disabled:
        self.dlg.generate_crossings.setEnabled(False)
        self.dlg.perc_draw_kerbs_box.setEnabled(False)
        self.dlg.perc_draw_kerbs_label.setEnabled(False)
        self.dlg.d_to_add_inward_box.setEnabled(False)
        self.dlg.label_inward_d.setEnabled(False)
        self.dlg.opt_parallel_crossings.setEnabled(False)
        self.dlg.opt_perp_crossings.setEnabled(False)

        # analyzing if the endpoits of splitted lines are elegible for  
        #   iterating again each street segment:

        # storing innerpoints, to then create a layer with them
        inner_pts_featlist = []

        # storing the direction vectors of crossings
        dirvecs_dict = {}

        # creating a spatial index for sidewalks
        # sidewalks_spatial_index = gen_layer_spatial_index(self.whole_sidewalks,False)

        # to count time 
        ref_time = time.time()

        # for progressbar:
        featcount = self.splitted_lines.featureCount()


        for i,feature_A in enumerate(self.splitted_lines.getFeatures()):

            P0 = qgs_point_geom_from_line_at(feature_A)    # first point
            PF = qgs_point_geom_from_line_at(feature_A,-1) # last point

            P0_count = 0
            PF_count = 0

            featurelen = feature_A.geometry().length()

            featurewidth = feature_A[widths_fieldname]

            feature_osm_id = feature_A['id'] 

            feature_layer_id = feature_A.id()

            # filling with 
            P0_intersecting_widths = {} #[]
            PF_intersecting_widths = {} #[]


            # tolerance for considering that a crossing center will have the crossing effectively drawn
            # a: two times (half width plus self.dlg.d_to_add_box.value())
            # b: three times half the width
            tolerance_draw_crossing = featurewidth + self.dlg.d_to_add_box.value()

            # # 3 times to KNN search 
            # # KNN search was deprecated
            # # tol_search_d = 3 * tolerance_draw_crossing

            for j,feature_B in enumerate(self.splitted_lines.getFeatures()):
                # if not i == j:
                if P0.intersects(feature_B.geometry()):
                    P0_count += 1

                    if not feature_B.id() == feature_layer_id:
                        if not feature_osm_id == feature_B['id']: 
                            P0_intersecting_widths[feature_B.id()] = feature_B['width']


                if PF.intersects(feature_B.geometry()):
                    PF_count += 1

                    if not feature_B.id() == feature_layer_id:
                        if not feature_osm_id == feature_B['id']: 
                            PF_intersecting_widths[feature_B.id()] = feature_B['width']


            # print(i+1,P0_intersecting_widths)
            # print(i+1,PF_intersecting_widths,'\n')


            # print(i,P0_count,PF_count)

            # getting the "orthogonal" widths as the 

            # print(P0_intersecting_widths,'\n',PF_intersecting_widths,'\n\n')

            # doing for the point at the beggining of segment:
            if P0_count > 2:
                tr_widthP0, trfeat_idP0 = get_major_dif_signed(featurewidth,P0_intersecting_widths)

                d_to_interpolate_P0 = (tr_widthP0 * 0.5) + self.curveradius + self.dlg.d_to_add_inward_box.value()

                # checking if its bigger than half the feature length:
                if d_to_interpolate_P0 > (0.5 * featurelen):
                    d_to_interpolate_P0 = featurelen * perc_to_interpolate

                innerP0_0 = feature_A.geometry().interpolate(d_to_interpolate_P0) #(self.curveradius*1.5)
                # print(distance_geom_another_layer(innerP0_0,self.whole_sidewalks,True,True))

                # getting distances from inner_points to sidewalks:
                # dlist_P0 = distance_geom_another_layer(innerP0_0,self.whole_sidewalks,True)
                # dlist_P0 = distance_geom_another_layer(innerP0_0,self.whole_sidewalks,True,False,sidewalks_spatial_index,tol_search_d,3)

                # print(i+1,dlist_P0) 

                innerP0_id = f"{feature_layer_id}_P0"

                # if items_minor_than_inlist(tolerance_draw_crossing,dlist_P0) == 2:
                # transforming as a feature, storing osm id
                innerP0_feat = QgsFeature()
                innerP0_feat.setGeometry(innerP0_0)
                innerP0_feat.setAttributes([feature_osm_id,innerP0_id])
                inner_pts_featlist.append(innerP0_feat)



                # # # part for the "cross-cut" segment
                # # cr_feature_P0 = feature_from_fid(self.splitted_lines,trfeat_idP0) 


                # # # then: lineLocatePoint
                # # # line = QgsGeometry.fromPolyline([line_start,line_end])
                # # # thx: https://gis.stackexchange.com/a/59196/49900

                # testing by doing some buffer

                '''
                    in the next functions, we:

                        - create the candidate points, intersecting lines with circle 

                        - find the index of the point that forms the minor angle 

                        - create the vector containing the direction of the crossing
                '''



                if self.dlg.opt_parallel_crossings.isChecked():
                    pts_inters_P0 =  points_intersecting_buffer_boundary(P0,self.splitted_lines,list(P0_intersecting_widths))

                    # chosen index:
                    ch_index = point_forms_minor_angle_w2(innerP0_0,P0,pts_inters_P0,True)

                    dirvecs_dict[innerP0_id] = vector_from_2_pts(P0,pts_inters_P0[ch_index],tolerance_draw_crossing)

                if self.dlg.opt_perp_crossings.isChecked():

                    # creating a perpendicular vector:
                    #    first, we create a vector parallel to the current street segment
                    seg_parallel_vector = vector_from_2_pts(P0,innerP0_0,tolerance_draw_crossing)

                    dirvecs_dict[innerP0_id] = seg_parallel_vector.perpVector()

                    # now the direction perpendicular vector:



                    


                # this part should be done after decimating only elegible points



            # summing up to obtain points in each side and creating line   geometries to find intersections (at the function)








            # doing for the point at the end of segment:
            if PF_count > 2:

                tr_widthPF, trfeat_idPF = get_major_dif_signed(featurewidth,PF_intersecting_widths)


                d_to_interpolate_PF = (tr_widthPF * 0.5) + self.curveradius + d_to_add_interp_d

                # checking if its bigger than half the feature length:
                if d_to_interpolate_PF > (0.5 * featurelen):
                    d_to_interpolate_PF = featurelen * perc_to_interpolate

                # since we are interpolating from the end and by QGIS 3.20 it does not support negative interpolation, we just subtract from total feature length
                innerPF_0 = feature_A.geometry().interpolate(featurelen-d_to_interpolate_PF)

                innerPF_id = f"{feature_layer_id}_PF"

                # print(distance_geom_another_layer(innerPF_0,self.whole_sidewalks,True,True))

                # getting distances from inner_points to sidewalks:
                # dlist_PF = distance_geom_another_layer(innerPF_0,self.whole_sidewalks,True)
                # dlist_PF = distance_geom_another_layer(innerPF_0,self.whole_sidewalks,True,False,sidewalks_spatial_index,tol_search_d,3) 


                # print(dlist_PF,'\n') 

                # if items_minor_than_inlist(tolerance_draw_crossing,dlist_PF) == 2:
                    # transforming as a feature, storing osm id
                innerPF_feat = QgsFeature()
                innerPF_feat.setGeometry(innerPF_0)
                innerPF_feat.setAttributes([feature_osm_id,innerPF_id])
                inner_pts_featlist.append(innerPF_feat)


                '''
                    in the next functions, we:

                        - create the candidate points, intersecting lines with circle 

                        - find the index of the point that forms the minor angle 

                        - create the vector containing the direction of the crossing
                '''


                if self.dlg.opt_parallel_crossings.isChecked():
                    pts_inters_PF =  points_intersecting_buffer_boundary(PF,self.splitted_lines,list(PF_intersecting_widths))


                    # chosen index:
                    ch_index = point_forms_minor_angle_w2(innerPF_0,PF,pts_inters_PF,True)

                    dirvecs_dict[innerPF_id] = vector_from_2_pts(PF,pts_inters_PF[ch_index],tolerance_draw_crossing)


                if self.dlg.opt_perp_crossings.isChecked():

                    # creating a perpendicular vector:
                    #    first, we create a vector parallel to the current street segment
                    seg_parallel_vector = vector_from_2_pts(PF,innerPF_0,tolerance_draw_crossing)

                    dirvecs_dict[innerPF_id] = seg_parallel_vector.perpVector()

                # part for the "cross-cut" segment
                # cr_feature_PF = feature_from_fid(self.splitted_lines,trfeat_idPF) 

            # # self.dlg.gencrossings_progressbar.setValue(int(i/featcount*100))
            
        
        inner_crossings_layer_0 = layer_from_featlist(inner_pts_featlist,crossing_centers_layername,attrs_dict={'osm_generator_id':QVariant.String,'crossing_center_id':QVariant.String})
        inner_crossings_layer_0.setCrs(self.custom_localTM_crs)


        # NEW METHOD to select elegible crossing centers: by buffer crossing centers and test if the tiny circles are within the big protoblocks layer
        inner_crossings_buff = generate_buffer(inner_crossings_layer_0,1,5,False,'ROUND')
        inner_crossings_buff.setCrs(self.custom_localTM_crs)

        # only circles within the dissolved protoblocks are mantained
        keep_only_contained_within(inner_crossings_buff,self.dissolved_protoblocks_0)

        # clipping the crossing centers:
        self.inner_crossings_layer = cliplayer_v2(inner_crossings_layer_0,inner_crossings_buff,'memory:'+crossing_centers_layername)

        """
            now doing computation of crossing points   
        """

        crossings_featlist = []

        kerbs_featlist = []

        for feature in self.inner_crossings_layer.getFeatures():

            key = feature['crossing_center_id']



            pA_crossings,pE_crossings = self.two_intersections_byvector_with_sidewalks(dirvecs_dict[key],feature.geometry())

            # stuff for kerb points ("B" and "D") computation

            pC = feature.geometry().asGeometryCollection()[0].asPoint()


            segment_AC = QgsGeometry.fromPolylineXY([pA_crossings.asPoint(),pC])
            segment_EC = QgsGeometry.fromPolylineXY([pE_crossings.asPoint(),pC])

            kerb_perc = self.dlg.perc_draw_kerbs_box.value()

            pB = interpolate_by_percent(segment_AC,kerb_perc)
            pD = interpolate_by_percent(segment_EC,kerb_perc)

            kerbs_featlist.append(geom_to_feature(pB))
            kerbs_featlist.append(geom_to_feature(pD))


            pA_feat = geom_to_feature(pA_crossings)
            pB_feat = geom_to_feature(pB)
            pD_feat = geom_to_feature(pD)
            pE_feat = geom_to_feature(pE_crossings)


            # print(pA_feat,pE_feat)

            pA_feat = geom_to_feature(pA_crossings)
            self.inner_crossings_layer.dataProvider().addFeature(pA_feat)
            self.inner_crossings_layer.dataProvider().addFeature(pB_feat)
            self.inner_crossings_layer.dataProvider().addFeature(pD_feat)           
            self.inner_crossings_layer.dataProvider().addFeature(pE_feat)

            # creating the crossings as line geometry:
            crossing_pointlist = [pA_crossings.asPoint(),pB.asPoint(),pC,pD.asPoint(),pE_crossings.asPoint()]

            crossing_as_feat = geom_to_feature(QgsGeometry.fromPolylineXY(crossing_pointlist))

            crossings_featlist.append(crossing_as_feat)

        # creating and styling the crossings and kerbs layers

        self.crossings_layer = layer_from_featlist(crossings_featlist,crossings_layer_name,"LineString")
        self.crossings_layer.setCrs(self.custom_localTM_crs)

        crossings_stylefile_path = os.path.join(assets_path,crossings_stylefilename)
        self.crossings_layer.loadNamedStyle(crossings_stylefile_path)

        self.kerbs_layer = layer_from_featlist(kerbs_featlist,kerbs_layer_name)
        self.kerbs_layer.setCrs(self.custom_localTM_crs)


        kerbs_stylefile_path = os.path.join(assets_path,kerbs_stylefilename)
        self.kerbs_layer.loadNamedStyle(kerbs_stylefile_path)



        # self.add_layer_canvas(self.inner_crossings_layer)
        self.add_layer_canvas(self.crossings_layer)
        self.add_layer_canvas(self.kerbs_layer)
        # self.add_layer_canvas(inner_crossings_buff)
        # self.add_layer_canvas(self.protoblocks)
        # self.add_layer_canvas(self.dissolved_protoblocks_0)


        # Enabling What Shall be used afterwards:
        self.dlg.split_sidewalks.setEnabled(True)


        # self.dlg.gencrossings_progressbar.setValue(100)

                  

        
            




    def draw_sidewalks(self):

        # disabling what should not be used afterwards:
        self.dlg.check_if_overlaps_buildings.setEnabled(False)
        self.dlg.generate_sidewalks.setEnabled(False)
        self.dlg.widths_hint.setHidden(True)


        # if no buildings, we can directly generate a simply dissolved-big_buffer
        if self.no_buildings or not self.dlg.check_if_overlaps_buildings.isChecked():
            

            pass

            # as of last code editing, I realized that one must only edit widths, so...
        else:

            # BUT if we have buildings, sidewalks must not overlap'em
            # buffering shall be done feature by feature and if overlaps the bunch of polygons
            # first, we create a dissolved poligon, we may test what 
            # then we check distances


            dissolved_buildings = dissolve_tosinglepart(self.reproj_buildings)

            dissolved_feature_geom = get_first_feature_or_geom(dissolved_buildings,True)

            widths_index = self.splitted_lines.fields().indexOf(widths_fieldname)

            with edit(self.splitted_lines):
                for i,feature in enumerate(self.splitted_lines.getFeatures()):

                    # distance to nearest building
                    d_to_nearest_building = feature.geometry().distance(dissolved_feature_geom)

                    # actually projected distance (half the width plus half the "distance to be add", avaliable at the GUI):
                    ac_prj_d = feature['width']/2 + self.dlg.d_to_add_box.value()/2
                    
                    # discounting the minimum distance, so it will always be considered
                    dif = (d_to_nearest_building - self.dlg.min_d_buildings_box.value()) - ac_prj_d

                    # dividing and multiplying by 2 as buffer is done side-by-side

                    if dif < 0:

                        new_width = 2 * (ac_prj_d + dif)

                        if new_width < self.dlg.min_width_box.value():
                            # imagine the worst case where someone has created  a building intersecting or nearly touching the very road
                            new_width = self.dlg.min_width_box.value()


                        # finally, editing the field when needed 
                        self.splitted_lines.changeAttributeValue(feature.id(),widths_index,new_width)
                        


                                                

                    # print(d_to_nearest_building,feature['width']/2,i)
        
        buffer_distance_string = f'("width" /2)+{self.dlg.d_to_add_box.value()/2}'

        # print(buffer_distance_string)

        proto_dissolved_buffer_step1 = generate_buffer(self.splitted_lines,buffer_distance_string)
        
        # rounding directly, as it avoids small polygons aswell
        # TODO: check if it's the best approach, or to do it feature-wise
        self.curveradius = self.dlg.curve_radius_box.value()

        proto_dissolved_buffer_step2 = generate_buffer(proto_dissolved_buffer_step1,self.curveradius)

        dissolved_buffer = generate_buffer(proto_dissolved_buffer_step2,-self.curveradius)



        # just for sanity always set the CRS
        dissolved_buffer.setCrs(self.custom_localTM_crs)


        # now generating the big buffer to extract the sidewalks
        big_temporary_buffer = generate_buffer(dissolved_buffer,big_buffer_d)
        big_temporary_buffer.setCrs(self.custom_localTM_crs)

        # difference layer:
        diff_layer = compute_difference_layer(big_temporary_buffer,dissolved_buffer)
        diff_layer.setCrs(self.custom_localTM_crs)


        # to singleparts:
        diff_layer_as_singleparts = convert_multipart_to_singleparts(diff_layer)
        remove_biggest_polygon(diff_layer_as_singleparts,True) # also recording areas for later use
        diff_layer_as_singleparts.setCrs(self.custom_localTM_crs)


        self.whole_sidewalklayer_name = self.string_according_language('SIDEWALKS','CALÇADAS')

        # finally, the sidewalks as boundaries (before any division):
        self.whole_sidewalks = extract_lines_from_polygons(diff_layer_as_singleparts,'memory:'+self.whole_sidewalklayer_name)
        self.whole_sidewalks.setCrs(self.custom_localTM_crs)

        # first, deleting all previous fields:
        remove_layerfields(self.whole_sidewalks,get_column_names(self.whole_sidewalks))
        '''
            tags to denote it's a sidewalk
            footway=sidewalk
            highway=footway

            then filling:
        '''
        create_filled_newlayerfield(self.whole_sidewalks,'highway','footway',QVariant.String)
        create_filled_newlayerfield(self.whole_sidewalks,'footway','sidewalk',QVariant.String)

        # styling the sidewalks layer
        sidewalk_stylefile_path = os.path.join(assets_path,sidewalks_stylefilename)

        self.whole_sidewalks.loadNamedStyle(sidewalk_stylefile_path)
        #  self.whole_sidewalks.triggerRepaint()

        # self.add_layer_canvas(big_temporary_buffer) #just for test
        # self.add_layer_canvas(dissolved_buffer) #just for test
        # self.add_layer_canvas(diff_layer) #just for test
        self.add_layer_canvas(self.whole_sidewalks)


        # to (probably) speed up intersections:
        self.dissolved_sidewalks = dissolve_tosinglepart(self.whole_sidewalks)
        self.dissolved_sidewalks_geom = get_first_feature_or_geom(self.dissolved_sidewalks,True)
        


        # stuff for later use 
        

        

        # disabling what won't be needed afterwards
        self.dlg.min_d_buildings_box.setEnabled(False)
        self.dlg.min_d_label.setEnabled(False)
        self.dlg.curve_radius_box.setEnabled(False)
        self.dlg.curveradius_label.setEnabled(False)

        self.dlg.d_to_add_box.setEnabled(False)
        self.dlg.d_to_add_label.setEnabled(False)
        self.dlg.min_width_box.setEnabled(False)
        self.dlg.min_width_label.setEnabled(False)

        # enabling what shall be enabled afterwards:
        self.dlg.generate_crossings.setEnabled(True)
        self.dlg.perc_draw_kerbs_box.setEnabled(True)
        self.dlg.perc_draw_kerbs_label.setEnabled(True)
        self.dlg.d_to_add_inward_box.setEnabled(True)
        self.dlg.label_inward_d.setEnabled(True)
        self.dlg.opt_parallel_crossings.setEnabled(True)
        self.dlg.opt_perp_crossings.setEnabled(True)
        # self.dlg.gencrossings_progressbar.setEnabled(True)




                



    def string_according_language(self,en_str,ptbr_str):
        if self.current_lang == 'en':
            return en_str
        else:
            return ptbr_str

    def remove_temporary_layers(self):

        is_temporary = [layer.isTemporary() for layer in QgsProject.instance().mapLayers().values()]

        layer_fullnames = [layer for layer in QgsProject.instance().mapLayers()]

        for i,status in enumerate(is_temporary):
            if status:
                QgsProject.instance().removeMapLayer(layer_fullnames[i])


    # # def replace_vectorlayer(self,layername,newpath):
    # #     remove_layerlist([layername])

    # #     replaced =  QgsVectorLayer(newpath,layername,'ogr')

    # #     self.add_layer_canvas(replaced)

    def disable_all_because_sidewalks(self):
        # DISABLING STUFF, if there are sidewalks already drawn, one must step back!!

        self.dlg.button_box.button(QDialogButtonBox.Ok).setEnabled(False)
        self.dlg.datafetch.setEnabled(False)
        self.dlg.ch_ignore_buildings.setEnabled(False)
        self.dlg.ch_ignore_buildings.setChecked(False)
        self.dlg.input_layer_selector.setEnabled(False)
        self.dlg.higway_values_table.setEnabled(False)
        self.dlg.clean_data.setEnabled(False)
        self.dlg.output_file_selector.setEnabled(False)

        self.dlg.dead_end_iters_label.setEnabled(False)
        self.dlg.dead_end_iters_box.setEnabled(False)


        # objects that must be hidden:
        self.dlg.generate_sidewalks.setHidden(True)
        self.dlg.check_if_overlaps_buildings.setHidden(True)
        self.dlg.min_d_buildings_box.setHidden(True)
        self.dlg.min_d_label.setHidden(True)
        self.dlg.curve_radius_box.setHidden(True)
        self.dlg.curveradius_label.setHidden(True)

        self.dlg.d_to_add_box.setHidden(True)
        self.dlg.d_to_add_label.setHidden(True)
        self.dlg.min_width_box.setHidden(True)
        self.dlg.min_width_label.setHidden(True)

        self.dlg.generate_crossings.setHidden(True)
        self.dlg.perc_draw_kerbs_box.setHidden(True)
        self.dlg.perc_draw_kerbs_label.setHidden(True)
        self.dlg.d_to_add_inward_box.setHidden(True)
        self.dlg.label_inward_d.setHidden(True)
        self.dlg.opt_parallel_crossings.setHidden(True)
        self.dlg.opt_perp_crossings.setHidden(True)
        # self.dlg.gencrossings_progressbar.setHidden(True)
        self.dlg.widths_hint.setHidden(True)




        # but enable the warning and the button:
        self.dlg.sidewalks_warning.setHidden(False)
        self.dlg.sidewalks_warning.setGeometry(270,180, 331, 281)

        self.dlg.ignore_already_drawn_btn.setHidden(False)
        self.dlg.ignore_already_drawn_btn.setEnabled(True)
        self.dlg.ignore_already_drawn_btn.setGeometry(300,450, 261, 71)
        # values from Qt Designer

    def ignore_already_drawn_fcn(self):

        self.reset_fields()

        # the trick is, by default the previous function set this control variable as false, 
        # then right after its call we revert the variable value (bug 001 memories)
        self.ignore_sidewalks_already_drawn = True


        # print(self.ignore_sidewalks_already_drawn)





    def reset_fields(self):
        # to be activated/deactivated/changed:
        self.dlg.input_layer_selector.setLayer(None)
        self.dlg.input_layer_selector.setEnabled(True)
        self.dlg.button_box.button(QDialogButtonBox.Ok).setEnabled(True)
        self.dlg.datafetch.setEnabled(False)
        self.dlg.ch_ignore_buildings.setEnabled(False)
        self.dlg.ch_ignore_buildings.setChecked(False)
        self.dlg.higway_values_table.setEnabled(False)
        self.dlg.clean_data.setEnabled(False)
        self.dlg.output_file_selector.setEnabled(False)
        self.dlg.generate_sidewalks.setEnabled(False)
        self.dlg.check_if_overlaps_buildings.setEnabled(False)
        self.dlg.check_if_overlaps_buildings.setChecked(False)
        self.dlg.ignore_already_drawn_btn.setEnabled(False)
        self.dlg.datafetch_progressbar.setEnabled(False)
        self.dlg.dead_end_iters_label.setEnabled(False)
        self.dlg.generate_crossings.setEnabled(False)
        self.dlg.perc_draw_kerbs_box.setEnabled(False)
        self.dlg.perc_draw_kerbs_label.setEnabled(False)
        self.dlg.d_to_add_inward_box.setEnabled(False)
        self.dlg.label_inward_d.setEnabled(False)
        self.dlg.opt_parallel_crossings.setEnabled(False)
        self.dlg.opt_perp_crossings.setEnabled(False)
        # self.dlg.gencrossings_progressbar.setEnabled(False)


        # self.dlg.gencrossings_progressbar.setValue(0)
        self.dlg.datafetch_progressbar.setValue(0)
        

        self.dlg.min_d_buildings_box.setEnabled(False)
        self.dlg.min_d_label.setEnabled(False)
        self.dlg.curve_radius_box.setEnabled(False)
        self.dlg.curveradius_label.setEnabled(False)

        self.dlg.d_to_add_box.setEnabled(False)
        self.dlg.d_to_add_label.setEnabled(False)
        self.dlg.min_width_box.setEnabled(False)
        self.dlg.min_width_label.setEnabled(False)

        self.dlg.add_osm_basemap.setEnabled(True)
        self.dlg.add_bing_base.setEnabled(True)

        # default value setting:
        self.dlg.min_d_buildings_box.setValue(min_d_to_building)
        self.dlg.curve_radius_box.setValue(default_curve_radius)
        self.dlg.d_to_add_box.setValue(d_to_add_to_each_side*2)
        self.dlg.min_width_box.setValue(minimal_buffer*2)
        self.dlg.perc_draw_kerbs_box.setValue(perc_draw_kerbs)
        self.dlg.d_to_add_inward_box.setValue(d_to_add_interp_d)


        #hidden elements
        self.dlg.widths_hint.setHidden(True)
        self.dlg.ignore_already_drawn_btn.setHidden(True)
        self.dlg.sidewalks_warning.setHidden(True)


        # table controlling
        self.dlg.higway_values_table.setRowCount(0)
        self.dlg.higway_values_table.setColumnCount(0)

        # objects that shall be visible by default
        self.dlg.generate_sidewalks.setHidden(False)
        self.dlg.check_if_overlaps_buildings.setHidden(False)
        self.dlg.min_d_buildings_box.setHidden(False)
        self.dlg.min_d_label.setHidden(False)
        self.dlg.curve_radius_box.setHidden(False)
        self.dlg.curveradius_label.setHidden(False)

        self.dlg.d_to_add_box.setHidden(False)
        self.dlg.d_to_add_label.setHidden(False)
        self.dlg.min_width_box.setHidden(False)
        self.dlg.min_width_label.setHidden(False)

        self.dlg.generate_crossings.setHidden(False)
        self.dlg.perc_draw_kerbs_box.setHidden(False)
        self.dlg.perc_draw_kerbs_label.setHidden(False)
        self.dlg.d_to_add_inward_box.setHidden(False)
        self.dlg.label_inward_d.setHidden(False)
        self.dlg.opt_parallel_crossings.setHidden(False)
        self.dlg.opt_perp_crossings.setHidden(False)

        self.dlg.split_sidewalks.setHidden(False)


        self.dlg.perc_draw_kerbs_box.setHidden(False)
        self.dlg.perc_draw_kerbs_label.setHidden(False)
        self.dlg.d_to_add_inward_box.setHidden(False)
        self.dlg.label_inward_d.setHidden(False)
        self.dlg.opt_parallel_crossings.setHidden(False)
        self.dlg.opt_perp_crossings.setHidden(False)

        # self.dlg.gencrossings_progressbar.setHidden(False)

        self.dlg.opt_parallel_crossings.setChecked(True)
        
        # control variables:
        if self.ignore_sidewalks_already_drawn:
            self.ignore_sidewalks_already_drawn = False
     
        # control variables:
        self.no_buildings = True


        # texts, for appearance:
        self.set_text_based_on_language(self.dlg.input_status,'waiting a valid input...','aguardando uma entrada válida...',self.change_input_labels)
        self.set_text_based_on_language(self.dlg.input_status_of_data,'waiting for data...','aguardando dados...',self.change_input_labels)

        # also wipe data:
        self.remove_layers_and_wipe_files([osm_higway_layer_finalname,buildings_layername],temps_path)

        # remove temporary layers:
        self.remove_temporary_layers()

        # and refresh canvas:
        self.iface.mapCanvas().refresh()



    def get_input_layer(self):
        # self.input_layer = QgsMapLayerComboBox.currentLayer()
        self.input_layer = self.dlg.input_layer_selector.currentLayer()

        # .next()

        if self.input_layer:
            self.write_to_debug(self.input_layer.dataProvider().dataSourceUri())


            # assuring 4326 as EPSG code for layer
            layer_4326 = reproject_layer(self.input_layer)



            input_feature = QgsFeature()


            iterat = layer_4326.getFeatures()

            iterat.nextFeature(input_feature)

            if input_feature.hasGeometry():
                # TODO: beware of qgis bugs...


                if input_feature.isValid():
                    self.input_polygon = input_feature.geometry()

                    # self.write_to_debug(self.input_polygon.toWkt())

                    bbox = self.input_polygon.boundingBox()

                    # in order to create a local custom projection
                    self.bbox_center = bbox.center()

                    self.minLgt = bbox.xMinimum()
                    self.minLat = bbox.yMinimum()
                    self.maxLgt = bbox.xMaximum()
                    self.maxLat = bbox.yMaximum()


                    if self.input_polygon.isGeosValid():
                        # zooming to inputlayer:
                        if self.iface.mapCanvas().mapSettings().destinationCrs().authid() == CRS_LATLON_4326:
                            self.iface.mapCanvas().setExtent(layer_4326.extent())
                        else:
                            bbox_4326 = get_bbox4326_currCRS(layer_4326.extent(),self.iface.mapCanvas().mapSettings().destinationCrs().authid())
                            self.iface.mapCanvas().setExtent(bbox_4326)
                        self.iface.mapCanvas().refresh()

                        # setting a default style for input polygons:
                        inputpolygons_stylelayerpath = os.path.join(assets_path,inputpolygons_stylefilename)

                        self.input_layer.loadNamedStyle(inputpolygons_stylelayerpath)


                        self.dlg.datafetch.setEnabled(True)
                        self.dlg.datafetch_progressbar.setEnabled(True)
                        self.dlg.ch_ignore_buildings.setEnabled(True)

                        # self.change_input_labels = False
                        # self.dlg.input_status.setText('Valid Input!')
                        self.set_text_based_on_language(self.dlg.input_status,'Valid Input!','Entrada Válida!')
                        # self.dlg.input_status_of_data.setText('waiting for data...')
                        self.set_text_based_on_language(self.dlg.input_status_of_data,'waiting for data...','Aguardando Dados...')


                        for item in [self.minLgt,self.minLat,self.maxLgt,self.maxLat]:
                            self.write_to_debug(item)
            else:
                # self.dlg.input_status.setText('no geometries on input!!')
                self.set_text_based_on_language(self.dlg.input_status,'no geometries on input!!','Entrada sem geometrias!!')
                self.dlg.datafetch.setEnabled(False)
                self.dlg.ch_ignore_buildings.setEnabled(False)

        else:

            # self.dlg.input_status.setText('waiting a valid for input...')
            self.set_text_based_on_language(self.dlg.input_status,'Waiting for a valid input...','Aguardando entrada válida...')
            self.dlg.datafetch.setEnabled(False)
            self.dlg.ch_ignore_buildings.setEnabled(False)







        

    def remove_layers_and_wipe_files(self,layernamelist,folderpath=None):
        '''
            one can also pass no folderpath to just remove layerlist
        '''
       
        remove_layerlist(layernamelist)

        if folderpath:
            wipe_folder_files(folderpath)


    
    # called at "Fetch Data" or self.datafetch button
    def call_get_osm_data(self): 
        """
        Function to call the functions from "osm fetch" module
        """

        # to prevent user to loop
        self.dlg.input_layer_selector.setEnabled(False)
        self.dlg.add_osm_basemap.setEnabled(False)
        self.dlg.add_bing_base.setEnabled(False)



        # PART 1 : wiping old stuff
        # delete files from previous session:
        #   and remove layers from project

        self.remove_layers_and_wipe_files([osm_higway_layer_finalname,buildings_layername],temps_path)
        self.remove_temporary_layers() # also temporary layers that can be around

        self.dlg.datafetch_progressbar.setValue(10)


        # PART 2: Getting and transforming the data
        self.dlg.datafetch.setEnabled(False)
        self.dlg.ch_ignore_buildings.setEnabled(False)


        # OSM query
        roads_layername = "osm_road_data"
        query_string = osm_query_string_by_bbox(self.minLat,self.minLgt,self.maxLat,self.maxLgt)
        # acquired file
        data_geojsonpath = get_osm_data(query_string,roads_layername)

        self.dlg.datafetch_progressbar.setValue(30)

        
        clipped_path = data_geojsonpath.replace('.geojson','_clipped.geojson')

        clip_polygon_path = path_from_layer(self.input_layer)

        self.write_to_debug(clip_polygon_path)

        # adding as layer
        osm_data_layer = QgsVectorLayer(data_geojsonpath,roads_layername,"ogr")

        cliplayer(osm_data_layer,self.input_layer,clipped_path)

        self.dlg.datafetch_progressbar.setValue(35)



        clipped_datalayer = QgsVectorLayer(clipped_path,roads_layername,"ogr")

        # # Custom CRS, to use metric stuff with minimal distortion
        self.clipped_reproj_path = data_geojsonpath.replace('.geojson','_clipped_reproj.geojson')


        self.clipped_reproj_datalayer, self.custom_localTM_crs = reproject_layer_localTM(clipped_datalayer,self.clipped_reproj_path,osm_higway_layer_finalname,lgt_0=self.bbox_center.x())

        self.dlg.datafetch_progressbar.setValue(40)



        # # not the prettier way to get also the buildings (yes, could create a function, its not lazyness, I swear...):
        # # no need for clipping the buildings layer 

        if not self.dlg.ch_ignore_buildings.isChecked() and use_buildings:
            query_string_buildings = osm_query_string_by_bbox(self.minLat,self.minLgt,self.maxLat,self.maxLgt,'building',relation=include_relations)
            buildings_geojsonpath = get_osm_data(query_string_buildings,'osm_buildings_data','Polygon')
            buildings_brutelayer = QgsVectorLayer(buildings_geojsonpath,'brute_buildings','ogr')

            self.no_buildings = check_empty_layer(buildings_brutelayer) # asserts if there are buildings in the area

            self.dlg.datafetch_progressbar.setValue(45)


            # do not add buildings if there's no need
            if not self.no_buildings:
                
                self.dlg.check_if_overlaps_buildings.setChecked(True) # set as default option, since sidewalks can overlap buildings

                reproj_buildings_path = buildings_geojsonpath.replace('.geojson','_reproj.geojson')
                self.dlg.datafetch_progressbar.setValue(50)

                self.reproj_buildings, _ = reproject_layer_localTM(buildings_brutelayer,reproj_buildings_path,buildings_layername,lgt_0=self.bbox_center.x())
                self.dlg.datafetch_progressbar.setValue(55)

                if draw_buildings:
                    self.add_layer_canvas(self.reproj_buildings)



                buildings_centroids = gen_centroids_layer(self.reproj_buildings)
                # self.add_layer_canvas(centroids)

            # # # else:
            # # #     # as there's no problem in an empty layer, mostly for ease posterior merging
            #####       also, mergelayers function can accept a list with only one 
            # # #     centroids = centroids_layer(buildings_brutelayer)
            
            self.dlg.datafetch_progressbar.setValue(60)


            """
            # adresses parts (there are just points in osm database, generally from mapping agencies i.e. IBGE), 
            # should be joined with centroids 
            # and be the default method for sidewalk splitting
            """

            # mostly a clone of get buildings snippet
            query_string_addrs = osm_query_string_by_bbox(self.minLat,self.minLgt,self.maxLat,self.maxLgt,'addr:housenumber',node=True)
            addrs_geojsonpath = get_osm_data(query_string_addrs,'osm_addrs_data','Point')
            self.dlg.datafetch_progressbar.setValue(65)

            addrs_brutelayer = QgsVectorLayer(addrs_geojsonpath,'brute_buildings','ogr')

            self.no_addrs = check_empty_layer(addrs_brutelayer)

            self.dlg.datafetch_progressbar.setValue(70)


            if not self.no_addrs:
                reproj_addrs_path = addrs_geojsonpath.replace('.geojson','_reproj.geojson')
                self.reproj_addrs, _ = reproject_layer_localTM(addrs_brutelayer,reproj_addrs_path,'addrs_points',lgt_0=self.bbox_center.x())
                # self.add_layer_canvas(self.reproj_addrs)

            self.dlg.datafetch_progressbar.setValue(75)


            '''             
            now the cases to create combined layer w/wout centroids and adresses:
            both unavaliable: nothing to do, as there a variable @POI_split_avaliable already set for that case 
            both avaliable: merge 
            if only addrs, merge 
            if only centoids, merge
            '''

            if not self.no_buildings or not self.no_addrs:
                self.POI_split_avaliable = True

                layersto_merge = []

                if not self.no_buildings:
                    layersto_merge.append(buildings_centroids)

                if not self.no_addrs:
                    layersto_merge.append(self.reproj_addrs)

                pois_splitting_name = self.string_according_language('addrs_and_buildings_centroids','enderecos_e_centroides')

                self.POIs_for_splitting_layer = mergelayers(layersto_merge,self.custom_localTM_crs,'memory:'+pois_splitting_name)

                self.add_layer_canvas(self.POIs_for_splitting_layer)


        
        self.dlg.datafetch_progressbar.setValue(90)

                 

        # a little cleaning:
        #   move do self.data_clean?
        # it just removes lines that are really not connected
        remove_unconnected_lines(self.clipped_reproj_datalayer)






        # adding to canvas
        self.add_layer_canvas(self.clipped_reproj_datalayer)

        # PART 3: Getting Attributes and drawing table:
        higway_list = get_layercolumn_byname(self.clipped_reproj_datalayer,highway_tag)




        self.dlg.datafetch_progressbar.setValue(95)

        # Table Filling
        self.dlg.higway_values_table.setEnabled(True)

        self.unique_highway_values = list(set(higway_list))

        self.dlg.higway_values_table.setRowCount(len(self.unique_highway_values))
        self.dlg.higway_values_table.setColumnCount(2)

        if self.current_lang == 'en':
            self.dlg.higway_values_table.setHorizontalHeaderLabels(['tag value','width'])
        else:
            self.dlg.higway_values_table.setHorizontalHeaderLabels(['valor','largura'])


        # filling first colum --> higway:values and second --> defalt_values
        for i,item in enumerate(self.unique_highway_values):
            vvalue = self.unique_highway_values[i]

            self.dlg.higway_values_table.setItem(i,0,QTableWidgetItem(vvalue))

            self.dlg.higway_values_table.setItem(i,1,QTableWidgetItem(str(default_widths[vvalue])))


        
        # Finally, enabling next button:
        self.dlg.clean_data.setEnabled(True)
        self.dlg.dead_end_iters_label.setEnabled(True)
        self.dlg.dead_end_iters_box.setEnabled(True)



        # BUT... if there are sidewalks already drawn, one must step back!!
        if sidewalk_tag_value in self.unique_highway_values:
            # DISABLING STUFF
            if not self.ignore_sidewalks_already_drawn:
                self.disable_all_because_sidewalks()

                self.ignore_sidewalks_already_drawn = True


        # # # testing if inverse transformation is working:
        # # self.add_layer_canvas(reproject_layer(self.clipped_reproj_datalayer))



        self.set_text_based_on_language(self.dlg.input_status_of_data,'data acquired!','Dados Obtidos!!')
        self.dlg.datafetch_progressbar.setValue(100)


    def set_text_based_on_language(self,qt_object,en_txt,ptbr_txt,extra_control_bool=True):
        if extra_control_bool:
            if self.current_lang == 'en':
                qt_object.setText(en_txt)
            else:
                qt_object.setText(ptbr_txt)


    def write_to_debug(self,input_stringable,add_newline=True):
        with open(self.session_debugpath,'a+') as session_report:
            session_report.write(str(input_stringable))
            if add_newline:
                session_report.write('\n')

    def two_intersections_byvector_with_sidewalks(self,vector,centerpoint,print_points=False):

        # correct datatype (QgsPoint/QGSPointXY)
        if centerpoint.isMultipart():
            center_point = centerpoint.asGeometryCollection()[0].asPoint()
        else:
            center_point = centerpoint.asPoint()

        coef_sideA = 1
        coef_sideB = 1

        sideA_ok = False
        sideB_ok = False

        while not all([sideA_ok,sideB_ok]):
            # we may iterate, as the intersection can give more than one point or no point at all

            p_sideA = center_point + (vector * coef_sideA)
            p_sideB = center_point - (vector * coef_sideB)

            line_sideA = QgsGeometry.fromPolylineXY([center_point,p_sideA])
            intersec_sideA_0 = self.dissolved_sidewalks_geom.intersection(line_sideA)

            line_sideB = QgsGeometry.fromPolylineXY([center_point,p_sideB])
            intersec_sideB_0 = self.dissolved_sidewalks_geom.intersection(line_sideB)


            # print('lines: ',line_sideA,line_sideB)
            # print('intersections:',intersec_sideA_0,intersec_sideB_0)
            # print('vector,points: ',vector,'\n',p_sideA,p_sideB,'\n\n')
            # time.sleep(10)

            sideA_ok,intersec_sideA = check_sidewalk_intersection(intersec_sideA_0,center_point)
            sideB_ok,intersec_sideB = check_sidewalk_intersection(intersec_sideB_0,center_point)




            if not sideA_ok:
                coef_sideA *= 2
            if not sideB_ok:
                coef_sideB *= 2


        if print_points:
            print(intersec_sideA,intersec_sideB)

        return intersec_sideA,intersec_sideB


